# AUTOGENERATED! DO NOT EDIT! File to edit: 15_experiment_3_optimise_with_emp_model.ipynb (unless otherwise specified).

__all__ = ['get_learner', 'find_best_variation_per_category', 'filter_best_variations', 'param_affects',
           'merge_best_parameters']

# Cell
from .core import *
from .fontlearner import *
from .fontsampler import *
from .ocrlearner import *
from collections import OrderedDict
from enum import Enum, auto
from fastai.data.all import *
from fastai.vision.all import *
import gc
from nbdev.showdoc import *
from pandas import DataFrame
from PIL.ImageOps import invert
import pydiffvg
import torch
from typing import Callable, List, Protocol, Tuple, Union

# Cell
def get_learner(
    ocr_fn: str,
    ocr_arch = cornet_for_ocr,
    n_out = 26,
    seed = 42,
    use_ocr_tfms = True,
    use_translate = True,
    tfms_p = 1.,
    bs: int = None,
    blur_random_size: Tuple[int, Sequence[int]] = 5,
    blur_sigma = (.1, 5),
    noise = 0.,
    **kwargs
    ) -> VectorLearner:
    gc.collect()
    ocr_model = load_ocr_model(file=ocr_fn, arch=ocr_arch, n_out=n_out)
    cb = DebugCB(vocal=False)
    ocr_tfms = []
    if ocr_arch is cornet_for_ocr:
        ocr_tfms += [Pad((48 - 28) // 2, fill=1.),
                     ToRGB(),
                     # DebugTfm("After Pad"),
                     get_imagenet_norm()]
    if use_ocr_tfms:
        # These are the same ones as used for the OCR model
        # max_rotate = 15.0
        # max_warp = .25
        # size = 28
        # tfms = aug_transforms(mult=1.0, do_flip=False, flip_vert=False, max_rotate=max_rotate,
        #                       min_zoom=0.85, max_zoom=1.15, max_warp=max_warp, p_affine=tfms_p,
        #                       p_lighting=0., xtra_tfms=None, size=size, mode='bilinear',
        #                       pad_mode='reflection', align_corners=True, batch=False,
        #                       min_scale=1.0)
        # warp = tfms[0]
        # ocr_tfms = [warp, blur]
        # if tfms_set == "default":  ocr_tfms += noise
        if use_translate: ocr_tfms += [TranslateAndPad(p=tfms_p)]
        ocr_tfms += [GaussianBlur(p=tfms_p, sigma=blur_sigma, random_size=blur_random_size)]
        if noise: ocr_tfms += [Noise(p=tfms_p, f=(0., noise))]
    learner = create_font_learner(ocr_tfms=ocr_tfms if len(ocr_tfms) else None,
                                letters=None,
                                cbs=cb,
                                ocr_model=ocr_model,
                                n_colors_out=1,
                                lr=1e-1,
                                init_range=2.,
                                seed=seed,
                                bs=bs,
                                **kwargs)
    if use_ocr_tfms: assert len(learner.loss_func.ocr_loss.tfms) == len(ocr_tfms)
    return learner

# Cell
from .core import *
from .fontlearner import *
from .fontsampler import *
from .ocrlearner import *
from collections import OrderedDict
from enum import Enum, auto
from fastai.data.all import *
from fastai.vision.all import *
import gc
from nbdev.showdoc import *
from pandas import DataFrame
from PIL.ImageOps import invert
import pydiffvg
import torch
from typing import Callable, List, Protocol, Tuple, Union

# Cell
from .core import *
from .fontlearner import *
from .fontsampler import *
from .ocrlearner import *
from collections import OrderedDict
from enum import Enum, auto
from fastai.data.all import *
from fastai.vision.all import *
import gc
from nbdev.showdoc import *
from pandas import DataFrame
from PIL.ImageOps import invert
import pydiffvg
import torch
from typing import Callable, List, Protocol, Tuple, Union

# Cell

def find_best_variation_per_category(
    vars: list[dict],
    cat_loss_col="per_category_loss",
) -> dict:
    """Find the best variations for each letter category."""
    losses = {k:[] for k in vars[0][cat_loss_col].keys()}
    for o in vars:
        for k,v in o[cat_loss_col].items(): losses[k].append(v)
    mins = {k:min(v)  for k,v in losses.items()}
    out = {}
    for k,v in mins.items():
        for o in vars:
            if o[cat_loss_col][k] == v:
                out[k] = o; break
    return out

def filter_best_variations(
    compare_to: dict,
    best_vars: dict,
    min_improvement=.1,
    cat_loss_col="per_category_loss",
) -> dict:
    """Filter the dict produced by `find_best_variation_per_category` to only
       include letters where improvement to `compared_to` exceeds `min_improvement`."""
    out = {}
    for k,v in best_vars.items():
        if compare_to[cat_loss_col][k] - v[cat_loss_col][k] >= min_improvement:
            out[k] = v
    return out

def param_affects(param_name: str,
    letters: str,
    incl_general = True,
    strict = False,
    ) -> bool:
    """Check if `param_name` affects any of the `letters`. If `incl_general`
       also returns `True` for general params. If `strict`, only return
       parameters that affect no other `letters`."""
    assert not strict or not incl_general
    pl = get_param_letters(param_name)
    if pl is None: return incl_general
    for l in pl:
        if strict and l not in letters: return False
        if not strict and l in letters: return True
    return strict

def merge_best_parameters(
    vars: list[dict],
    base_idx=0,
    min_improvement=.1,
    vocal=True,
    param_col="final_params",
    cat_loss_col="per_category_loss",
) -> dict:
    """Merge the best parameters for each letter to params of variation at `base_idx`
       and return a param_dict."""
    base = vars[base_idx]
    out = {**base[param_col]}
    best_vars = find_best_variation_per_category(vars, cat_loss_col=cat_loss_col)
    best_vars = filter_best_variations(base, best_vars, min_improvement=min_improvement, cat_loss_col=cat_loss_col)
    # Only select params that do not affect other letters
    affected_params = [o for o in base[param_col].keys() if \
                       param_affects(o, best_vars.keys(), strict=True, incl_general=False)]
    for p in affected_params:
        # Get a mean over the best params for each of the affected letters
        v = mean([best_vars[o][param_col][p] for o in get_param_letters(p)])
        if vocal: print(f"Change '{p}' from {out[p]:.4} => {v:.4}")
        out[p] = v
    return out