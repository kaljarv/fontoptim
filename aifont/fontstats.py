# AUTOGENERATED! DO NOT EDIT! File to edit: 04_font_statistics.ipynb (unless otherwise specified).

__all__ = ['GOOGLE_FONTS_LETTER_WIDTHS_PATH', 'TMNIST_STATS_PATH', 'calc_glyph_dimensions', 'glyph_dimensions',
           'calc_glyph_widths_with_font_sampler', 'glyph_widths', 'normalise_glyph_widths', 'plot_glyph_widths',
           'norm_widths']

# Cell
from .core import *
from .fontsampler import *
from .ocrlearner import *
from collections import OrderedDict
from enum import Enum, auto
from fastai.data.all import *
from fastai.vision.all import *
import gc
from itertools import combinations
from nbdev.showdoc import *
import pandas as pd
from pandas import DataFrame
import PIL
from PIL import ImageFont
import pydiffvg
import torch
from typing import Callable, List, Protocol, Tuple, Union

# Cell

GOOGLE_FONTS_LETTER_WIDTHS_PATH = f"{GOOGLE_FONT_ROOT_PATH}/google-fonts-letter-widths.csv"
TMNIST_STATS_PATH = "data/94_character_TMNIST_glyph_dims.csv"


# Cell

def calc_glyph_dimensions(
    df: DataFrame = None,
    report_every = 100
    ) -> DataFrame:
    """Return a DataFrame that contains the bounding box data for each glyph,
       as well as font name, letter index in vocab and letter string but not
       the pixel values."""
    if df is None: df = get_tmnist_images(undersample=False, drop_extra_cols=False)
    n_rows = len(df)
    px_cols = int(df.columns[-1])
    px_size = float(math.sqrt(px_cols))
    glyph_bounds = np.empty((n_rows, 6))
    for i in range(n_rows):
        if i % report_every == 0: print(f"Processing row {i + 1} of {n_rows}...")
        lft, top, rgt, btm = px_size + 1, px_size + 1, -1., -1.
        for j in range(0, px_cols):
            # Check if pixel at j is not white and use the grey level
            # to calculate an approximation of the subpixel position
            # which ranges from 0 to size
            # NB. reverse values; pixel col names start from 1
            v = df.iloc[i][str(j + 1)]
            if v > 0.1:
                fr = v / 255
                row_n = j // px_size
                col_n = j % px_size
                if row_n < top: top = row_n + 1 - fr
                if row_n > btm: btm = row_n + fr
                if col_n < lft: lft = col_n + 1 - fr
                if col_n > rgt: rgt = col_n + fr
        glyph_bounds[i] = rgt - lft, btm - top, lft, top, rgt, btm
    # Create return df
    print("Creating statistics DataFrame")
    norm_cols = ["width_norm", "height_norm"]
    dim_cols = ["width", "height", "left", "top", "right", "bottom"]
    meta_cols = ["names", "labels", "labels_num"]
    col_order = meta_cols + norm_cols + dim_cols
    res = DataFrame(glyph_bounds)
    res.columns = dim_cols
    res.index = df.index
    for c in meta_cols:
        res[c] = df[c]
    res.sort_values(by=["names", "labels_num"], inplace=True)
    # Calc normalised values
    means = res.groupby(["names"]).mean()
    stds = res.groupby(["names"]).std()
    norms = np.empty((n_rows, 2))
    for i in range(n_rows):
        r = res.iloc[i]
        norms[i] = [(r[x] - means.loc[r.names][x]) / (stds.loc[r.names][x] + 1e-8) for x in ("width", "height")]
    res["width_norm"]  = norms[:, 0]
    res["height_norm"] = norms[:, 1]
    res = res[col_order]
    return res

# df = get_tmnist_images(undersample=False, drop_extra_cols=False)
# glyph_dimensions = calc_glyph_dimensions(df)
# glyph_dimensions.to_csv(TMNIST_STATS_PATH)
glyph_dimensions = pd.read_csv(TMNIST_STATS_PATH)
glyph_dimensions.head()

# Cell

def calc_glyph_widths_with_font_sampler(
    size = 256,
    category="sans-serif",
    variants=["regular", "medium"],
    subsets=["latin"],
    vocab = VOCAB_UC
    ) -> DataFrame:
    text_size = size // 2
    fs = FontSampler(category=category, variants=variants, subsets=subsets)
    n_fonts = fs.num_fonts
    n_letters = len(vocab)
    res = np.empty((n_fonts, n_letters))
    font_names = [None] * n_fonts
    for i in range(n_fonts):
        if i % 20 == 0: print(f"Font {i + 1} of {n_fonts}")
        # We can't use the getsize method as it includes padding
        # widths = np.array([font.getsize(l)[0] for l in vocab])
        widths = []
        for l in vocab:
            # Render and transpose
            rend, font_name = fs.render_text(l, text_size, font_index=i, image_width=size, image_height=size,
                                             include_font=True, as_normalised_array=True)
            rend = rend.T
            left, right = size, -1
            for c in range(0, size):
                # Check if any value in column is non-zero
                if np.greater(rend[c], .5).any(): left = c; break
            for c in range(left, size):
                v = size - c - 1
                if rend[v].any(): right = v; break
            widths.append(right - left if right > -1 else None)
        res[i] = widths
        font_names[i] = font_name
    res_df = DataFrame(res)
    res_df.columns = vocab
    res_df.index = font_names
    return res_df

# glyph_widths = calc_glyph_widths_with_font_sampler()
# glyph_widths.to_csv(GOOGLE_FONTS_LETTER_WIDTHS_PATH)
glyph_widths = pd.read_csv(GOOGLE_FONTS_LETTER_WIDTHS_PATH)
glyph_widths.head()

# Cell

def normalise_glyph_widths(
    glyph_widths: DataFrame,
    std_limit = .1,
    plot = True,
    **plot_args
    ) -> DataFrame:
    """Normalise the glyph widths in the df and filter out fonts where
       the standard deviation as a fraction of the mean is too small."""
    means = glyph_widths.mean(axis=1)
    stds  = glyph_widths.std(axis=1)
    shape = list(glyph_widths.shape)
    shape[1] = shape[1] + 1 # Add one col
    res   = np.empty(shape)
    eps   = 1e-8
    for i in range(len(glyph_widths)):
        mean = means.iloc[i]
        std  = stds.iloc[i] + eps
        res[i] = list((glyph_widths.iloc[i] - mean) / std) + [std / mean]
    res_df = DataFrame(res)
    res_df.columns = list(glyph_widths.columns) + ["font_std"]
    res_df.index = glyph_widths.index
    res_df = res_df[res_df.font_std > std_limit]
    res_df.drop(columns="font_std", inplace=True)
    if plot: plot_glyph_widths(res_df, **plot_args)
    return res_df

def plot_glyph_widths(
    res_df: DataFrame,
    figsize = (10, 6),
    y_range: Tuple[float, float] = None
    ) -> None:
    """Make a box plot of the glyph widths."""
    l_order = list(res_df.columns)
    l_means = res_df.mean()
    l_order.sort(key=lambda x: l_means[x])
    fig = plt.figure(figsize=figsize)
    ax = res_df[l_order].boxplot(showfliers=False)
    if y_range is not None: ax.set_ylim(*y_range)
    fig.suptitle(f"Letter width in within-font SDs for FontSampler fonts")
    plt.show()

norm_widths = normalise_glyph_widths(glyph_widths, plot=False)
plot_glyph_widths(norm_widths, y_range=(-1.5, 1.5))